#include <Arduino.h>
#include <Wire.h>
#include <esp_task_wdt.h>
/*inclusão das Biblioteca do FreeRTOS*/
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
//#include <MAX30100_PulseOximeter.h>
#include "MAX30105.h"
#include "spo2_algorithm.h"
#include "heartRate.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include <WiFi.h>                       //Biblioteca do Wifi
//#include <WebServer.h>                  //Biblioteca do Servidor do Portal
//#include <DNSServer.h>                  //Biblioteca do webserver local usado para direcionar todas as requisições para o portal
//#include <WiFiManager.h>                //Biblioteca do Wifi Manager Magic

TaskHandle_t xTaskPoxHandle, xTaskDisplayHandle, xTaskSensorHandle, xTaskTecladoHandle;
QueueHandle_t xMenuValuequeue;
QueueHandle_t xMenuEnterqueue;

#define SCREEN_WIDTH            128   // OLED display width, in pixels
#define SCREEN_HEIGHT           64    // OLED display height, in pixels
#define REPORTING_PERIOD_MS     1
#define RATE_SIZE 4 
/*  Saídas definidas no esp32
    As saídas 21,22 e 16,17 sao usadas 
    Para s Interface I2C  */
#define ONEWIREBUS              5    //Sensor de temperadura
#define BT_ENTER                23
#define BT_UP                   1
#define BT_DOWN                 3

MAX30105  pox;
Adafruit_SSD1306 display(SCREEN_WIDTH,SCREEN_HEIGHT,&Wire1,-1);
OneWire onewire(ONEWIREBUS);
DallasTemperature sensor(&onewire);
//WiFiManager wifiManager;

void vTaskPox(void *pvParameters);
void vTaskDisplay(void *pvParameters);
void vTaskSensor(void *pvParameters);
void vTaskTeclado(void *pvParameters);

void drawLogo(int i, int j);
void position(int item);


void InitHW(void);

void page_1(uint8_t *Tela_de_destino);
void page_2(uint8_t *Tela_de_destino);

//void configModeCallback (WiFiManager *myWiFiManager);
void saveConfigCallback (); 

//uint32_t xBPM = 0 , spo2 = 0;
float_t temp = 0.0;
ulong tempo = 0;
enum {MENU = 0, PAGE_1, PAGE_2, PAGE_3};
bool stMode = false;

float BPM;
int beatAvg;
byte rates[RATE_SIZE]; //Array of heart rates
byte rateSpot = 0;
long lastBeat = 0; //Time at which the last beat occurred
int32_t bufferLength; //data length
int32_t spo2; //SPO2 value
int8_t validSPO2; //indicator to show if the SPO2 calculation is valid
int32_t heartRate; //heart rate value
int8_t validHeartRate; //indicator to show if the heart rate calculation is valid
uint32_t irBuffer[100]; //infrared LED sensor data
uint32_t redBuffer[100];  //red LED sensor data

void setup() {
  InitHW(); 
  uint8_t i = 0;
	do
	{
		/*Creates Queue with 5 positions and size of 16 bit Float*/
		xMenuValuequeue = xQueueCreate(5, sizeof (int8_t));
		Serial.print("[  ]:CREATING MENU QUEUE...\r");
		i++;
	} while ((xMenuValuequeue == NULL)||(i<10));
	if(xMenuValuequeue == NULL)
	{
		Serial.print("\n\r");
		Serial.println("***FATAL_ERROR***: MENU QUEUE WAS NOT CREATED!");
		while(1);
	}
	/*Creating Menu Enter Queue*/
	do
	{
		/*Creates Queue with 5 positions and size of 16 bit Float*/
		xMenuEnterqueue = xQueueCreate(5, sizeof (uint8_t));
		Serial.print("[  ]:CREATING MENU QUEUE...\r");
		i++;
	} while ((xMenuEnterqueue == NULL)||(i<10));
	if(xMenuEnterqueue == NULL)
	{
		Serial.print("\n\r");
		Serial.println("***FATAL_ERROR***: MENU ENTER QUEUE WAS NOT CREATED!");
		while(1);
	}
  xTaskCreatePinnedToCore(vTaskPox, "vTaskPox", configMINIMAL_STACK_SIZE + 2048, NULL, 1, &xTaskPoxHandle, 0);
  xTaskCreatePinnedToCore(vTaskDisplay, "vTaskDisplay", configMINIMAL_STACK_SIZE + 2048, NULL, 1, &xTaskDisplayHandle, 1);
  xTaskCreatePinnedToCore(vTaskSensor, "vTaskSensor", configMINIMAL_STACK_SIZE + 1024, NULL, 1, &xTaskSensorHandle, 0);
  xTaskCreatePinnedToCore(vTaskTeclado, "vTaskTeclado", configMINIMAL_STACK_SIZE + 1024, NULL, 1, &xTaskTecladoHandle, 0);
  
}

void loop() {
  vTaskDelay(pdMS_TO_TICKS(100));  
}

void InitHW()
{
  Serial.begin(115200);
  if(Wire.begin(21,22))
  {
    Serial.println("Wire Begin OK");
  }
  if (!pox.begin(Wire, I2C_SPEED_FAST,0x57))
   {
        Serial.println("Falha na Inicializacao do Sensor");
        for(;;);
    } else {
        Serial.println("Comunicacao Realizada com Sucesso!");
  }

  pox.setup(); //Configure sensor default settings
  pox.setPulseAmplitudeRed(0x0A); //Turn Red LED to low to indicate sensor is running
  pox.setPulseAmplitudeGreen(0); //Turn off Green LED

  Wire1.begin(18,19);
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) 
    {
      Serial.println(F("ERRO ao iniciar o display SSD1306"));
      for(;;);
    }
    else
    {
      Serial.println(F("Display iniciado com sucesso"));
    }
  drawLogo(4,1);
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(WHITE);

  sensor.begin();

  pinMode(BT_UP, 		INPUT_PULLUP);
	pinMode(BT_DOWN, INPUT_PULLUP);
	pinMode(BT_ENTER, 	INPUT_PULLUP);
}

void vTaskPox(void *pvParameters)
{
  (void) pvParameters;
  bufferLength = 100; 
  long irValue = pox.getIR();
  for (byte i = 0 ; i < bufferLength ; i++)
  {
    while (pox.available() == false) //do we have new data?
      pox.check(); //Check the sensor for new data

    redBuffer[i] = pox.getRed();
    irBuffer[i] = pox.getIR();
    pox.nextSample(); //We're finished with this sample so move to next sample
  }
   //calculate heart rate and SpO2 after first 100 samples (first 4 seconds of samples)
  maxim_heart_rate_and_oxygen_saturation(irBuffer, bufferLength, redBuffer, &spo2, &validSPO2, &heartRate, &validHeartRate);
  
  while (1)
  { 


    if (checkForBeat(irValue) == true)
    {
      //We sensed a beat!
      long delta = millis() - lastBeat;
      lastBeat = millis();

      BPM = 60 / (delta / 1000.0);

      if (BPM < 255 && BPM > 20)
      {
        rates[rateSpot++] = (byte)BPM; //Store this reading in the array
        rateSpot %= RATE_SIZE; //Wrap variable

        //Take average of readings
        beatAvg = 0;
        for (byte x = 0 ; x < RATE_SIZE ; x++)
        beatAvg += rates[x];
        beatAvg /= RATE_SIZE;
      }
    }

    if (irValue < 50000)
    {
      Serial.println(" No finger?");
    }else
    {
      Serial.print(", BPM=");
      Serial.print(BPM);
    }

    //dumping the first 25 sets of samples in the memory and shift the last 75 sets of samples to the top
    for (byte i = 25; i < 100; i++)
    {
      redBuffer[i - 25] = redBuffer[i];
      irBuffer[i - 25] = irBuffer[i];
    }

    //take 25 sets of samples before calculating the heart rate.
    for (byte i = 75; i < 100; i++)
    {
      while (pox.available() == false) //do we have new data?
        pox.check(); //Check the sensor for new data


      redBuffer[i] = pox.getRed();
      irBuffer[i] = pox.getIR();
      pox.nextSample(); //We're finished with this sample so move to next sample

      //send samples and calculation result to terminal program through UART

      Serial.print(F(", SPO2="));
      Serial.print(spo2, DEC);

      Serial.print(F(", SPO2Valid="));
      Serial.println(validSPO2, DEC);
    }

    //After gathering 25 new samples recalculate HR and SP02
    maxim_heart_rate_and_oxygen_saturation(irBuffer, bufferLength, redBuffer, &spo2, &validSPO2, &heartRate, &validHeartRate);
    
    vTaskDelay(pdMS_TO_TICKS(200));  
  }
}

void vTaskDisplay(void *pvParameters)
{
  uint8_t valor = 0, enter = 0, tela = MENU;
  static uint8_t posicao_atual = 0;	
  while (1)
  {
    if(xQueueReceive(xMenuEnterqueue,&enter,(TickType_t)100)==pdTRUE);
    if(xQueueReceive(xMenuValuequeue,&valor,(TickType_t)100)==pdTRUE);

     switch (tela)
    {
    case MENU:
        if(enter == 1)
        {
          tela = PAGE_1;
          enter = 0;
          posicao_atual = 0;
        }
        display.clearDisplay();
        display.setCursor(0,0);
        display.setTextSize(2);
        display.print(BPM);
        display.print("BPM");
        display.setCursor(0,18);
        display.print(spo2);
        display.print("%");
        display.setCursor(0,36);
        display.printf("%.1f",temp);
        display.drawCircle(55,36,2,WHITE);
        display.print(" C");
        display.setTextSize(1);
        display.setCursor(0,54);
        display.print("PRESS ENTER FOR MENU");
        display.display();
      break;

    case PAGE_1:
    {
      display.clearDisplay();
      display.setTextSize(2);
      display.setCursor(13,5);
      display.print("INICIO");
      display.setCursor(1,22);
      display.print("STATUS WIFI");
      display.setCursor(10,39);
      display.print("RECONNECT");
        
        if (posicao_atual == 0)
          {
            Serial.println("Dentro do Item INICIO");
            display.drawRoundRect(0,4,128,16,5,1);
        }else if (posicao_atual == 1)
          {
            Serial.println("Dentro do Item STATUS WIFI");
            display.drawRoundRect(0,21,128,16,5,1);
          }else if (posicao_atual == 2)
          {
            Serial.println("Dentro do Item RECONECT");
            display.drawRoundRect(0,38,128,16,5,1);
          }
                  
        display.display();
        Serial.println("valor ");
        Serial.print(valor);
        Serial.println("Posicao");
        Serial.print(posicao_atual);
  
        if (enter == 0 && valor == 2 && posicao_atual < 2)
        {
          Serial.println("dentro da soma");
          posicao_atual = posicao_atual +1;
          Serial.println(posicao_atual);
          valor = 1;
          delay(5000);
        }
        if (enter == 0 && valor == 0 && posicao_atual > 0)
        {
          Serial.println("Dentro da subtracao");
          posicao_atual= posicao_atual - 1;
          valor = 1;
          delay(5000);
        }
        if (enter == 1 && posicao_atual == 0)
        {
          tela = MENU;
          enter = 0;
          posicao_atual = 0;
        }
        if (enter == 1 && posicao_atual == 1)
        {
          tela = PAGE_2;
          enter = 0;
          posicao_atual = 0;
        }
        if (enter == 1 && posicao_atual == 1)
        {
          tela = PAGE_3;
          enter = 0;
          posicao_atual = 0;
        }
          
        vTaskDelay(pdMS_TO_TICKS(100));
        break;
    }
    case PAGE_2:
    {          
      // if(WiFi.isConnected())
      // {
      //   display.clearDisplay();  
      //   display.setCursor(0,0);
      //   display.setTextSize(1);
      //   display.print("CONECTADO COMO");
      //   display.setCursor(0,15);
      //   display.setTextSize(1);
      //   display.print(WiFi.SSID());
      //   display.display();
      // }else
      // {
      //   display.clearDisplay();  
      //   display.setCursor(10,10);
      //   display.setTextSize(2);
      //   display.print("Não Conectado");
      //   display.setCursor(10,15);
      //   display.display();
      //   if (stMode)
      //   {
      //     display.setTextSize(1);
      //     display.print("Entrar no endereço:");
      //     display.setCursor(0,20);
      //     display.print(WiFi.softAPIP());
      //     display.display();
      //   }else
      //   {
      //     display.setTextSize(1);
      //     display.setCursor(10,10);
      //     display.print("Entar no modo de RECONNECT");
      //     display.display();
      //   }
      // }
      
      if(enter == 1)
      {
        tela = MENU;
        enter = 0;
      }    
      break;
    }
    case PAGE_3:
    {
      display.clearDisplay();
      display.setCursor(0,10);
      display.setTextSize(1);
      display.print("MODO DE CONFIGURAÇÃO ATIVADO");
      display.setCursor(0,14);
      display.print("ACESSE A REDE WardIO NO SEU CELULAR");
      display.setCursor(0,18);
      display.print("ABRA O ENDEREÇO ");
      display.setCursor(0,22);
      display.print("192.168.4.1");
      display.setCursor(0,26);
      display.print("NO NAVEGADOR E CONFIGURE O WIFI");
      display.setCursor(0,30);
      display.print("QUANDO O DISPOSITIVO REINICIAR");
      display.setCursor(0,34);
      display.print("PRESSIONE ENTER PARA REINICIAR");
      display.display();
 
      if(enter == 1)
      {
        // WiFiManager wifiManager;
        // if(!wifiManager.startConfigPortal("WardIO") )
        //  {
        //     Serial.println("Falha ao conectar");
        //    delay(2000);
        //    ESP.restart();
        //  }
        tela = MENU;
        enter = 0;
      } 
      break;
    }
    default:
    {
      break;
    }
    }
    vTaskDelay(pdMS_TO_TICKS(200));
  }
  
}

void vTaskTeclado(void *pvParameters)
{
  (void) pvParameters;
  uint8_t enter = 0, value = 1;
  bool bt_up = 0,bt_down = 0, bt_enter = 0;
  while (1)
  {
    
    if (!digitalRead(BT_UP))
    {
      bt_up = 1;
      vTaskDelay(pdMS_TO_TICKS(50));
    }else 
    {
      bt_up = 0;
    }
    if (!digitalRead(BT_DOWN))
    {
      bt_down = 1;
      vTaskDelay(pdMS_TO_TICKS(50));
    }else 
    {
      bt_down = 0;
    }
    if (!digitalRead(BT_ENTER))
    {
      bt_enter = 1;
      vTaskDelay(pdMS_TO_TICKS(50));
    }
    else
    {
      bt_enter = 0;
    }
    
    if (bt_up)
    {
      value = 2;
    }
    if (bt_down)
    {
      value = 0;
    }
    if (bt_enter)
    {
      enter = 1;
    }
    else
    {
      enter=0;
    }

    xQueueSend(xMenuValuequeue, &value, portMAX_DELAY);
    xQueueSend(xMenuEnterqueue, &enter, portMAX_DELAY);
    enter = 0;
    value = 1;
    vTaskDelay(pdMS_TO_TICKS(100));
  }
  
}

void vTaskSensor(void *pvParameters)
{
  while (1)
  {
    sensor.requestTemperaturesByIndex(0);
    temp = sensor.getTempCByIndex(0);
    Serial.print(temp);
    Serial.println("°C");
    vTaskDelay(pdMS_TO_TICKS(1000));
  }
  
}

void drawLogo(int i,int j)
{
  
static const unsigned char logo_bmp_128x42_1 [] PROGMEM = {
// 'logo_bmp_128x42', 74x64px
0xff, 0xfe, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xc0, 0xff, 0xf0, 0x00, 0x1f, 0xff, 0xfe, 
0x00, 0x03, 0xff, 0xc0, 0xff, 0xc0, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xc0, 0xff, 0x00, 
0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x3f, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x38, 
0x1f, 0xc0, 0xfc, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x1e, 0x0f, 0xc0, 0xf8, 0x00, 0x00, 0x00, 
0x3f, 0x00, 0x00, 0x0f, 0x87, 0xc0, 0xf0, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x07, 0xc3, 0xc0, 
0xe0, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x03, 0xe1, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x0c, 0x00, 
0x00, 0x01, 0xf0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0xc0, 0x80, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xf8, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x40, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 
0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3c, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x40, 0xc0, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x38, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xc0, 0xe0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x71, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xc0, 
0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xc0, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x47, 0xc0, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0xfc, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x1f, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 
0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0xff, 0xc0, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0xff, 0xf0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
0xff, 0xc0, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0xff, 0xfe, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xc0, 
0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
0x01, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0xff, 0xff, 
0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xff, 
0xff, 0xc0, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0x80, 
0x00, 0x00, 0x7f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 
0xff, 0xff, 0xff, 0xe0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x07, 
0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
0xff, 0xfe, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0xff, 
0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 
0xe1, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xc0
};
static const unsigned char logo_bmp_128x42_2 [] PROGMEM = {
// 'logo_bmp_128x42', 74x64px
0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x01, 
0xff, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 
0xff, 0xfe, 0x00, 0x1f, 0xff, 0xff, 0xc0, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0xc7, 
0xe0, 0x00, 0x03, 0xff, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xe1, 0xf0, 0x00, 0x07, 0xff, 0xff, 0xff, 
0xc0, 0xff, 0xff, 0xf0, 0x78, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xf8, 0x3c, 0x00, 
0x1f, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xfc, 0x1e, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xf3, 0xff, 
0xff, 0xfe, 0x0f, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0x00, 0x7f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x07, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x80, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x83, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xc0, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xc1, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xc0, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xc1, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xc0, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc1, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xc0, 
0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xc3, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x80, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xc7, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x00, 0x1f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x8e, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9e, 0x00, 
0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbc, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xb8, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x03, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xe0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 
0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xfe, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x0f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 
0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xf0, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 
0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const unsigned char logo_bmp_18x16_1 [] PROGMEM = {// 'pngwave', 18x16px
0xe1, 0xe1, 0xc0, 0x80, 0xc0, 0x40, 0x80, 0x01, 0xc0, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 
0x00, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x40, 0x80, 0x00, 0x40, 0xc0, 0x00, 0xc0, 0xe0, 0x01, 
0xc0, 0xf0, 0x03, 0xc0, 0xf8, 0x07, 0xc0, 0xfc, 0x0f, 0xc0, 0xff, 0x3f, 0xc0, 0xff, 0x3f, 0xc0};
static const unsigned char logo_bmp_18x16_2 [] PROGMEM ={// 'pngwave', 18x16px
0xe1, 0xe1, 0xc0, 0x80, 0xc0, 0x40, 0x80, 0x01, 0xc0, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 
0x00, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x40, 0x80, 0x00, 0x40, 0xc0, 0x00, 0xc0, 0xe0, 0x01, 
0xc0, 0xf0, 0x03, 0xc0, 0xf8, 0x07, 0xc0, 0xfc, 0x0f, 0xc0, 0xff, 0x3f, 0xc0, 0xff, 0x3f, 0xc0,};

  for(int a = 0; a<i; a++ )
  {
    /*dispay.drawBitmap(pos x,pos y,*logo,LOGO_WIDTH,LOGO_HEIGHT,1);*/
    display.clearDisplay();
    display.drawBitmap(27, 0,  logo_bmp_128x42_1, 74, 64, WHITE);
    display.display();
    delay(250);
    display.clearDisplay();
    display.drawBitmap(27, 0,  logo_bmp_128x42_2, 74, 64, WHITE);
    display.display();
    delay(250);
  }
  display.clearDisplay();
  display.display();
}

// void position (int item)
// {
// 	if(item == 1)
// 		display.drawRoundRect(0,17,128,16,5,1);
	
// 	if(item == 2)
// 		display.drawRoundRect(0,33,128,16,5,1);
// }

// void page_1(uint8_t *Tela_de_destino)
// {
//   //itens menu;
//   uint8_t retornar = 0;
//   uint8_t posicao_do_menu = 1, posicao_anterior_do_menu = 2;
//   display.clearDisplay();
//   while (retornar == 0)
//   {
//     display.clearDisplay();
//     display.setTextSize(2);
//     display.setCursor(10,18);
//     display.print("ITEM 1");
//     display.setCursor(10,34);
//     display.print("ITEM 2");
//     display.display();
//     if (posicao_anterior_do_menu != posicao_do_menu)
//     {
//       switch (posicao_do_menu)
//       {
//       case 1:
//         Serial.println("Dentro do Item 1 da página 1 do menu");
//         display.drawRoundRect(0,17,128,16,5,1);
//         display.display();
//         break;
//       case 2:
//         Serial.println("Dentro do Item 2 da página 1 do menu");
//         display.drawRoundRect(0,33,128,16,5,1);
//         display.display();
//         break;
//       default:
//         break;
//       }
//       posicao_anterior_do_menu = posicao_do_menu;
//       vTaskDelay(pdMS_TO_TICKS(100));
//     }
//     if ((!digitalRead(BT_DOWN))&& posicao_do_menu == 1)
//     {
//       posicao_do_menu ++;
//       vTaskDelay(pdMS_TO_TICKS(100));
//     }else if ((!digitalRead(BT_UP))&& posicao_do_menu ==2)
//     {
//       posicao_do_menu --;
//       vTaskDelay(pdMS_TO_TICKS(100));
//     }
//     if (!digitalRead(BT_ENTER))
//     {
//       retornar = 1;
//       vTaskDelay(pdMS_TO_TICKS(100));
//     }
//     *Tela_de_destino = posicao_do_menu;
//     vTaskDelay(pdMS_TO_TICKS(100));    
//   }
// }
// void page_2(uint8_t *Tela_de_destino)
// {
//   vTaskDelay(pdMS_TO_TICKS(100));
// }